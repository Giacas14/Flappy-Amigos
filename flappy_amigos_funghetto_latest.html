<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Flappy Amigos</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            touch-action: manipulation; /* Disabilita il doppio tocco per lo zoom su mobile */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body class="bg-gray-900 flex flex-col items-center justify-center h-screen overflow-hidden p-2">

    <!-- Titolo del gioco -->
    <h1 id="title" class="text-4xl md:text-6xl mb-4 text-center" style="text-shadow: 3px 3px 0 #000; color: #FBBF24;">Flappy Amigos</h1>

    <!-- Canvas dove si svolge il gioco -->
    <div class="relative rounded-lg overflow-hidden shadow-2xl border-4 border-gray-700">
        <canvas id="gameCanvas" width="320" height="480"></canvas>
        
        <!-- Messaggio di Game Over -->
        <div id="gameOverScreen" class="absolute inset-0 bg-black bg-opacity-50 flex-col items-center justify-center text-white text-center p-4 hidden">
            <h2 class="text-4xl font-bold mb-2" style="color: #FBBF24;">GAME OVER</h2>
            <p class="text-xl mb-2">Punteggio: <span id="finalScore">0</span></p>
            <p class="text-xl mb-4">Migliore: <span id="bestScore">0</span></p>
            <p class="text-lg animate-pulse">Tocca per riprovare</p>
        </div>
        
        <!-- Messaggio di avvio -->
        <div id="startScreen" class="absolute inset-0 bg-black bg-opacity-25 flex flex-col items-center justify-center text-white text-center p-4 hidden">
             <p class="text-2xl animate-pulse">Tocca per iniziare</p>
        </div>
    </div>

    <!-- Punteggi -->
    <div class="flex justify-between w-full max-w-sm mt-4 text-white text-base px-4">
        <p>Punteggio: <span id="score">0</span></p>
        <p>Migliore: <span id="highScore">0</span></p>
    </div>


    <script>
        // Ottiene gli elementi dal DOM
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const finalScoreElement = document.getElementById('finalScore');
        const bestScoreElement = document.getElementById('bestScore');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startScreen = document.getElementById('startScreen');
        const titleElement = document.getElementById('title');

        // Impostazioni audio
        let audioCtx;

        // Impostazioni del gioco
        let bird = {
            x: 50,
            y: 150,
            width: 40,
            height: 40,
            gravity: 0.5,
            lift: -8,
            velocity: 0
        };

        const pipes = [];
        const pipeWidth = 52;
        const pipeGap = 130;
        let score = 0;
        let highScore = 0;
        let gameState = 'start';
        
        const clouds = [];
        const numClouds = 5;
        
        const collectables = [];
        let pipeCounter = 0;
        const collectableEmojis = ['ðŸ•¶ï¸', 'ðŸŽ§', 'ðŸ¾', 'ðŸŽ¶'];

        // Variabili per il controllo del tempo
        let lastTime = 0;
        // ** NUOVO: Logica basata sul tempo per la generazione dei tubi **
        let timeSinceLastPipe = 0;
        const pipeSpawnInterval = 1.5; // Genera un tubo ogni 1.5 secondi

        // Sistema di caricamento degli asset
        let assetsLoaded = 0;
        const totalAssets = 1;

        function onAssetLoad() {
            assetsLoaded++;
            if (assetsLoaded === totalAssets) {
                startScreen.classList.remove('hidden'); 
                requestAnimationFrame(gameLoop);
            }
        }
        
        const birdImg = new Image();
        birdImg.onload = onAssetLoad;
        birdImg.onerror = () => {
            console.error("Immagine del personaggio non caricata.");
            onAssetLoad();
        };
        birdImg.src = 'https://i.imgur.com/aoFVRBR.png';

        // Funzione per riprodurre suoni
        function playSound(frequency, type = 'sine', duration = 0.1) {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }
        
        function jump() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }

            if (gameState === 'playing') {
                bird.velocity = bird.lift;
                playSound(350, 'square', 0.05);
            } else if (gameState === 'start') {
                startGame();
            } else if (gameState === 'gameOver') {
                resetGame();
            }
        }
        
        function startGame() {
            gameState = 'playing';
            startScreen.classList.add('hidden');
            titleElement.classList.add('hidden');
            jump();
        }

        document.addEventListener('keydown', (e) => { if (e.code === 'Space') jump(); });
        canvas.addEventListener('mousedown', jump);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); });
        gameOverScreen.addEventListener('mousedown', jump);
        gameOverScreen.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); });
        startScreen.addEventListener('mousedown', jump);
        startScreen.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); });


        function drawBird() {
            ctx.drawImage(birdImg, bird.x, bird.y, bird.width, bird.height);
        }

        function drawPipes() {
            ctx.fillStyle = '#2E8B57';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            for (const p of pipes) {
                const topPipeHeight = p.topHeight;
                const bottomPipeY = topPipeHeight + pipeGap;
                const bottomPipeHeight = canvas.height - bottomPipeY;
                ctx.fillRect(p.x, 0, pipeWidth, topPipeHeight);
                ctx.strokeRect(p.x, 0, pipeWidth, topPipeHeight);
                ctx.fillRect(p.x - 5, topPipeHeight - 20, pipeWidth + 10, 20);
                ctx.strokeRect(p.x - 5, topPipeHeight - 20, pipeWidth + 10, 20);
                ctx.fillRect(p.x, bottomPipeY, pipeWidth, bottomPipeHeight);
                ctx.strokeRect(p.x, bottomPipeY, pipeWidth, bottomPipeHeight);
                ctx.fillRect(p.x - 5, bottomPipeY, pipeWidth + 10, 20);
                ctx.strokeRect(p.x - 5, bottomPipeY, pipeWidth + 10, 20);
            }
        }
        
        function initClouds() {
            clouds.length = 0;
            for (let i = 0; i < numClouds; i++) {
                clouds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.5,
                    radius: Math.random() * 20 + 20,
                    speed: Math.random() * 0.3 + 0.1,
                });
            }
        }

        function drawClouds() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (const cloud of clouds) {
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.radius, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.radius * 0.8, cloud.y, cloud.radius * 0.7, 0, Math.PI * 2);
                ctx.arc(cloud.x - cloud.radius * 0.7, cloud.y, cloud.radius * 0.6, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fill();
            }
        }

        function updateClouds(deltaTime) {
            for (const cloud of clouds) {
                cloud.x -= cloud.speed * 60 * deltaTime;
                if (cloud.x + cloud.radius * 2 < 0) {
                    cloud.x = canvas.width + cloud.radius;
                    cloud.y = Math.random() * canvas.height * 0.5;
                }
            }
        }

        function drawCollectables() {
            ctx.font = '30px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            for (const item of collectables) {
                ctx.fillText(item.emoji, item.x, item.y);
            }
        }

        function updateCollectables(deltaTime) {
            for (let i = collectables.length - 1; i >= 0; i--) {
                let item = collectables[i];
                item.x -= 2.5 * 60 * deltaTime;
                if (bird.x < item.x + item.width / 2 && bird.x + bird.width > item.x - item.width / 2 && bird.y < item.y + item.height / 2 && bird.y + bird.height > item.y - item.height / 2) {
                    playSound(700, 'triangle', 0.15);
                    collectables.splice(i, 1);
                } else if (item.x + item.width < 0) {
                    collectables.splice(i, 1);
                }
            }
        }

        function update(deltaTime) {
            if (gameState !== 'playing') return;
            
            updateClouds(deltaTime);
            updateCollectables(deltaTime);

            bird.velocity += bird.gravity * 60 * deltaTime;
            bird.y += bird.velocity * 60 * deltaTime;

            if (bird.y + bird.height > canvas.height || bird.y < 0) endGame();

            // ** MODIFICA: Generazione dei tubi basata sul tempo, non sui frame **
            timeSinceLastPipe += deltaTime;
            if (timeSinceLastPipe >= pipeSpawnInterval) {
                timeSinceLastPipe = 0; // Resetta il timer
                
                const minHeight = 40;
                const maxHeight = canvas.height - pipeGap - minHeight;
                let topHeight;

                const lastPipe = pipes[pipes.length - 1];
                if (lastPipe) {
                    const maxChange = 60;
                    const minNewHeight = Math.max(minHeight, lastPipe.topHeight - maxChange);
                    const maxNewHeight = Math.min(maxHeight, lastPipe.topHeight + maxChange);
                    topHeight = Math.floor(Math.random() * (maxNewHeight - minNewHeight + 1) + minNewHeight);
                } else {
                    topHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1) + minHeight);
                }
                
                pipeCounter++;
                if (pipeCounter > 0 && pipeCounter % 5 === 0) {
                    const randomEmoji = collectableEmojis[Math.floor(Math.random() * collectableEmojis.length)];
                    const itemY = topHeight + pipeGap / 2;
                    collectables.push({
                        x: canvas.width + (pipeWidth / 2),
                        y: itemY,
                        width: 35,
                        height: 35,
                        emoji: randomEmoji
                    });
                }
                
                pipes.push({ x: canvas.width, topHeight: topHeight, passed: false });
            }

            for (let i = pipes.length - 1; i >= 0; i--) {
                let p = pipes[i];
                p.x -= 2.5 * 60 * deltaTime; 
                if (p.x + pipeWidth < 0) pipes.splice(i, 1);
                const bottomPipeY = p.topHeight + pipeGap;
                if (bird.x < p.x + pipeWidth && bird.x + bird.width > p.x && (bird.y < p.topHeight || bird.y + bird.height > bottomPipeY)) {
                    endGame();
                }
                if (p.x + pipeWidth < bird.x && !p.passed) {
                    score++;
                    scoreElement.textContent = score;
                    p.passed = true;
                    playSound(523, 'sine', 0.1);
                }
            }
        }

        function draw() {
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#70c5ce');
            skyGradient.addColorStop(1, '#99d8db');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawClouds();
            drawPipes();
            drawCollectables();
            drawBird();
        }

        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            
            const maxDeltaTime = 1 / 30;
            const effectiveDeltaTime = Math.min(deltaTime, maxDeltaTime);

            update(effectiveDeltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        function updateHighScore() {
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('flappyAmigosHighScore', highScore);
            }
            highScoreElement.textContent = highScore;
            bestScoreElement.textContent = highScore;
        }

        function endGame() {
            if (gameState === 'gameOver') return;
            gameState = 'gameOver';
            playSound(150, 'sawtooth', 0.2);
            finalScoreElement.textContent = score;
            updateHighScore();
            gameOverScreen.classList.remove('hidden');
        }

        function resetGame() {
            bird.y = 150;
            bird.velocity = 0;
            pipes.length = 0; 
            score = 0;
            // ** MODIFICA: Resetta il timer dei tubi **
            timeSinceLastPipe = 0;
            scoreElement.textContent = score;
            gameState = 'playing';
            gameOverScreen.classList.add('hidden');
            initClouds();
            collectables.length = 0;
            pipeCounter = 0;
            jump();
        }

        function showLoadingScreen() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = "16px 'Press Start 2P'";
            ctx.textAlign = 'center';
            ctx.fillText('Caricamento...', canvas.width / 2, canvas.height / 2);
        }
        
        function loadHighScore() {
            const savedScore = localStorage.getItem('flappyAmigosHighScore');
            if (savedScore) {
                highScore = parseInt(savedScore, 10);
            }
            highScoreElement.textContent = highScore;
        }
        
        loadHighScore();
        initClouds();
        showLoadingScreen();
    </script>

</body>
</html>
